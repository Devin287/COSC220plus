(a)  Summarize your approach to the problem, and how your code addresses the abstractions needed.

	

(b)  What is the theoretical time complexity of your algorithms (best and worst case), in terms of theinput size?  Be sure to vary the parameters enough to use the observations to answer the nextquestions!

	The time complexity should be O(1) to peek since its the first item. For dequeue it should be O(logn) as well as insert since that is the time to go through a list in a heap.

(c)  How does the absolute timing of different algorithms scale with the input?  Use the data collectedto rectify this with the theoretical time complexity, e.g.  what non-asymptotic function ofnmostlyclosely matches the timings that you observe asngrows?

	

(d)  Describe 2-3 different larger application areas where a priority queue would be helpful.  Explainand give some justification why it would be a better choice than other data structures.
	
	One application could be a todo list that has tasks that need to be done with certain urgency. Another is giving streamers a higher priority when finding a match compared to casuals.

(e)  How could the code be improved in terms of usability, efficiency, and robustness?

	I could use pointers and try to manage where wach node is pointing as well as add more variables to determine priority.

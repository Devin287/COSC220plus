README:

(a)  Summarize your approach to the problem, and how your code addresses the abstractions needed.
	
I started with psuedo code on the lab document. After that I was getting errors because I was not using the struct correctly. I also still think I am not becuase I am not using the "arr" in the struct. How ever I then created a object of the struct called a. This would then access heap size and length.	

(b)  What is the theoretical time complexity of your sorting algorithm (best and worst case), in termsof the array size?
	
Best case is O(nlogn) and worst case is O(nlogn).

(c)  Test your sorting algorithm on different size and types of arrays, as you did with labs 1 and 2.Be sure to vary the parameters enough to use the observations to answer the next questions!

(d)  How does the absolute timing scale with the number of elements in the array?  The size of the elements?  Use the data collected to rectify this with the theoretical time complexity, e.g.  whatnon-asymptotic function of n mostly closely matches the timings that you observe as n grows?
	
	

(e)  Aggregate your data into a graph of the complexity for the various array sizes, for example witha spreadsheet program like LibreOffice Calc or Microsoft Word.

(f)  How does the sort perform in different cases?  What is the best and worst case, according to yourown test results?

	The best is when the array is ascending. While the worst is when the array is descending. Its average case is when its random. All of these cases seem reasonabl.

(g)  How could the code be improved in terms of usability, efficiency, and robustness?

	I could have used timesort, but I could not get it working. 
